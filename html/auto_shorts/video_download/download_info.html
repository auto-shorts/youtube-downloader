<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>auto_shorts.video_download.download_info API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>auto_shorts.video_download.download_info</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
import os
import pprint
from pathlib import Path
from typing import Any

import googleapiclient.discovery
import googleapiclient.errors
from pydantic import BaseModel

from auto_shorts.config import GCP_API_KEY

BASE_RESULT_KEYS = (
    &#34;contentDetails&#34;,
    &#34;snippet&#34;,
    &#34;statistics&#34;,
)

BASE_PLAYLIST_RESULT_KEYS = (
    &#34;contentDetails&#34;,
    &#34;snippet&#34;,
)


class VideoStatistics(BaseModel):
    comments: int | None
    likes: int | None
    views: int | None


class VideoData(BaseModel):
    id: str
    channel_id: str | None
    channel_title: str | None
    audio_language: str | None
    licensed: bool | None
    description: str | None
    published_at: str | None
    category_id: str | None
    tags: list[str] | None
    title: str | None


class VideoDataWithStats(VideoData):
    statistics: VideoStatistics | None


class VideoCategory(BaseModel):
    &#34;&#34;&#34;
    Class representing a video category on YouTube.

    Attributes
    ----------
    region_code : str
        The two-letter ISO 3166-1 alpha-2 country code for the region to which the video category belongs.
    category_id : str
        The ID of the video category.
    assignable : bool
        Whether the video category can be used as a target for new videos.
    category_title : str
        The title of the video category.
    &#34;&#34;&#34;
    region_code: str
    category_id: int
    category_title: str
    assignable: bool


class PlaylistVideoData(BaseModel):
    video_data: list[VideoData]
    next_page_token: str | None


def safe_get(dct: dict, *keys) -&gt; Any:
    &#34;&#34;&#34;Safely retrieve a value from a nested dictionary.

    Parameters
    ----------
    dct : dict
        A dictionary containing nested keys and values.
    *keys : Any
        One or more keys to use when traversing the dictionary.

    Returns
    -------
    Any
        The value at the end of the key traversal, or None if any of the keys are missing.

    &#34;&#34;&#34;
    for key in keys:
        try:
            dct = dct[key]
        except KeyError:
            return None
    return dct


def preprocess_video_response(video_data) -&gt; VideoData:
    return VideoData(
        id=safe_get(
            video_data,
            &#34;id&#34;,
        ),
        channel_id=safe_get(video_data, &#34;snippet&#34;, &#34;channelId&#34;),
        channel_title=safe_get(video_data, &#34;snippet&#34;, &#34;channelTitle&#34;),
        licensed=safe_get(video_data, &#34;contentDetails&#34;, &#34;licensedContent&#34;),
        audio_language=safe_get(video_data, &#34;snippet&#34;, &#34;defaultAudioLanguage&#34;),
        decripton=safe_get(video_data, &#34;snippet&#34;, &#34;description&#34;),
        published_at=safe_get(video_data, &#34;snippet&#34;, &#34;publishedAt&#34;),
        category_id=safe_get(video_data, &#34;snippet&#34;, &#34;categoryId&#34;),
        tags=safe_get(video_data, &#34;snippet&#34;, &#34;tags&#34;),
        title=safe_get(video_data, &#34;snippet&#34;, &#34;title&#34;),
    )


def preprocess_video_response_with_stats(video_data) -&gt; VideoDataWithStats:
    base_response = preprocess_video_response(video_data)
    statistics_data = safe_get(video_data, &#34;statistics&#34;)
    statistics = VideoStatistics(
        comments=safe_get(statistics_data, &#34;commentCount&#34;),
        likes=safe_get(statistics_data, &#34;likeCount&#34;),
        views=safe_get(statistics_data, &#34;viewCount&#34;),
    )
    return VideoDataWithStats(**base_response.dict(), statistics=statistics)


def preprocess_playlist_item_response(video_data) -&gt; VideoData:
    video_data_dict = preprocess_video_response(video_data).dict()
    idx = safe_get(video_data, &#34;contentDetails&#34;, &#34;videoId&#34;)
    video_data_dict[&#34;id&#34;] = idx
    return VideoData(**video_data_dict)


def preprocess_playlist(playlist_response) -&gt; PlaylistVideoData:
    items = safe_get(playlist_response, &#34;items&#34;)
    video_data = [preprocess_playlist_item_response(video_data) for video_data in items]
    next_page_token = safe_get(playlist_response, &#34;nextPageToken&#34;)
    return PlaylistVideoData(video_data=video_data, next_page_token=next_page_token)


class InfoDownloaderBase:
    &#34;&#34;&#34;
    Base class for downloading data from the YouTube API.
    &#34;&#34;&#34;
    def __init__(
            self,
            api_key: str = GCP_API_KEY,
            api_service_name: str = &#34;youtube&#34;,
            api_version: str = &#34;v3&#34;,
    ) -&gt; None:
        &#34;&#34;&#34;
        Initializes a new instance of the InfoDownloaderBase class.

        Args:
            api_key (str): Your GCP API key.
            api_service_name (str): The name of the API service to use (default: &#34;youtube&#34;).
            api_version (str): The version of the API to use (default: &#34;v3&#34;).
        &#34;&#34;&#34;
        self.youtube = googleapiclient.discovery.build(
            api_service_name, api_version, developerKey=api_key
        )


class CategoryInfoDownloader(InfoDownloaderBase):
    &#34;&#34;&#34;
    Class for downloading information about video categories from YouTube API.

    Methods:
        video_categories_by_region(region_code save_path)
            Fetches video categories for the given region code from the YouTube API.
    &#34;&#34;&#34;
    def video_categories_by_region(
            self, region_code: str, save_path: Path | None = None
    ) -&gt; list[VideoCategory]:
        &#34;&#34;&#34;
        Fetches video categories for the given region code from the YouTube API.

        Parameters
        ----------
        region_code : str
            The two-letter ISO 3166-1 alpha-2 country code for the region whose video categories are to be fetched.
        save_path : Optional[Path], optional
            The path where the fetched video categories data should be saved as a JSON file. Default value is None,
            which means the data won&#39;t be saved.

        Returns
        -------
        categories : List[VideoCategory]
            A list of VideoCategory objects, where each object contains information about a single video category.

        Raises
        ------
        HttpError
            If there&#39;s an error in fetching the video categories data from the YouTube API.
            &#34;&#34;&#34;
        request = self.youtube.videoCategories().list(
            part=&#34;snippet&#34;, regionCode=region_code
        )
        response = request.execute()
        categories = []

        for item in response[&#34;items&#34;]:
            snippet = item[&#34;snippet&#34;]
            category = VideoCategory(
                region_code=region_code,
                category_id=item[&#34;id&#34;],
                assignable=snippet[&#34;assignable&#34;],
                category_title=snippet[&#34;title&#34;],
            )
            categories.append(category)

        if save_path:
            os.makedirs(save_path, exist_ok=True)
            with open(save_path / f&#34;{region_code}.json&#34;, &#34;w&#34;) as file:
                json.dump(
                    [category.dict() for category in categories],
                    file,
                    indent=4,
                )

        return categories


class VideoInfoDownloader(InfoDownloaderBase):
    &#34;&#34;&#34;
    Downloads video information from YouTube using YouTube API v3.

    Args:
        result_keys (list): List of video information keys to download.
            Defaults to BASE_RESULT_KEYS.

    Methods:
        most_popular_videos(region_code, video_category_id, max_results):
            Returns the most popular videos for a given region or category.

        id_from_response(response):
            Extracts video ids from a response dictionary.

        download_video_data(video_id):
            Downloads video data for one or more video ids.

        video_id_by_page_token(page_token):
            Extracts video ids and a next page token from a page token.

        video_id_by_search_query(q, max_results, order):
            Returns video ids for a search query.

        video_data_by_search_query(q, max_results, order):
            Returns video data for a search query.
    &#34;&#34;&#34;
    def __init__(
            self,
            result_keys: list = BASE_RESULT_KEYS,
    ) -&gt; None:
        super().__init__()
        self.result_keys = result_keys

    def most_popular_videos(
            self,
            region_code: str | None = None,
            video_category_id: int | None = None,
            max_results: int | None = 100,
    ) -&gt; list[VideoDataWithStats]:
        &#34;&#34;&#34;
        Returns the most popular videos for a given region or category.

        Args:
            region_code (str): ISO 3166-1 alpha-2 code of the region. Defaults
                to None.
            video_category_id (int): ID of the video category. Defaults to None.
            max_results (int): Maximum number of results to return. Defaults to
                100.

        Returns:
            A list of VideoDataWithStats objects.
        &#34;&#34;&#34;
        request = self.youtube.videos().list(
            part=&#34;,&#34;.join(self.result_keys),
            chart=&#34;mostPopular&#34;,
            regionCode=region_code,
            videoCategoryId=video_category_id,
            maxResults=max_results,
        )
        all_videos = request.execute()[&#34;items&#34;]
        return [
            preprocess_video_response_with_stats(video_data)
            for video_data in all_videos
        ]

    @staticmethod
    def id_from_response(response: dict) -&gt; list[str]:
        &#34;&#34;&#34;
        Extracts video ids from a response dictionary.

        Args:
            response (dict): The response dictionary.

        Returns:
            A list of video ids.
        &#34;&#34;&#34;
        return [
            safe_get(video_data, &#34;id&#34;, &#34;videoId&#34;) for video_data in response[&#34;items&#34;]
        ]

    def download_video_data(self, video_id: str) -&gt; list[VideoDataWithStats]:
        &#34;&#34;&#34;
        Downloads video data for one or more video ids.

        Args:
            video_id (str): One or more video ids separated by comma.

        Returns:
            A list of VideoDataWithStats objects.
        &#34;&#34;&#34;
        request = self.youtube.videos().list(
            part=&#34;,&#34;.join(self.result_keys), id=video_id
        )
        response = request.execute()[&#34;items&#34;]
        video_data_preprocessed = []

        for video_data in response:
            video_data_preprocessed.append(
                preprocess_video_response_with_stats(video_data)
            )

        return video_data_preprocessed

    def video_id_by_page_token(self, page_token: str) -&gt; tuple[list[str], str]:
        &#34;&#34;&#34;
        Extracts video ids and a next page token from API using previous page token.

        Args:
            page_token (str): A page token.

        Returns:
            A tuple of a list of video ids and the next page token.
        &#34;&#34;&#34;
        request = self.youtube.search().list(part=&#34;snippet&#34;, pageToken=page_token)
        response = request.execute()
        try:
            next_page_token = response[&#34;nextPageToken&#34;]
            return self.id_from_response(response), next_page_token
        except KeyError:
            pprint.pprint(response)

    def video_id_by_search_query(
            self, q: str, max_results: int = 100, order: str = &#34;viewCount&#34;
    ) -&gt; list[str]:
        &#34;&#34;&#34;
        Returns video ids for a search query.

        Args:
            q (str): The search query.
            max_results (int): Maximum number of results to return. Defaults to
                100.
            order (str): The order of the results. Defaults to &#34;viewCount&#34;.

        Returns:
            A list of video ids.
        &#34;&#34;&#34;
        request = self.youtube.search().list(
            q=q,
            part=&#34;snippet&#34;,
            maxResults=max_results,
            order=order,
            type=&#34;video&#34;
            # videoLicense=&#34;creativeCommon&#34;, To check later!
        )
        response = request.execute()
        video_id = self.id_from_response(response)
        next_page_token = response[&#34;nextPageToken&#34;]

        while len(video_id) &lt; max_results:
            tmp_video_id, next_page_token = self.video_id_by_page_token(next_page_token)
            video_id.extend(tmp_video_id)

        return video_id

    def video_data_by_search_query(
            self, q: str, max_results: int = 100, order: str = &#34;viewCount&#34;
    ) -&gt; list[VideoDataWithStats]:
        &#34;&#34;&#34;
        Returns video data for a search query.

        Args:
            q (str): The search query.
            max_results (int): Maximum number of results to return. Defaults to
                100.
            order (str): The order of the results. Defaults to &#34;viewCount&#34;.

        Returns:
            A list of VideoDataWithStats objects.
        &#34;&#34;&#34;
        video_id = self.video_id_by_search_query(
            q=q, max_results=max_results, order=order
        )
        return self.download_video_data(video_id=&#34;,&#34;.join(video_id))


class ChannelInfoDownloader(InfoDownloaderBase):
    &#34;&#34;&#34;
    A class for downloading information about videos from a YouTube channel.

    Args:
        result_keys (tuple): A tuple of keys to be included in the request for the
            channel&#39;s video information.

    Methods:
        _get_user_playlist_id_from_video(video_id: str) -&gt; str:
            Returns the ID of the playlist containing the videos for the specified
            video ID.

        _next_page_download(next_page_token: str, playlist_id: str) -&gt; PlaylistVideoData:
            Downloads the next page of videos from the specified playlist and returns
            the preprocessed data.

        get_videos_from_channel(video_id: str, video_number_limit: int = 1000)
            -&gt; list[VideoData]:
            Returns a list of VideoData objects containing the video information from
            the specified channel up to the specified limit.
    &#34;&#34;&#34;
    def __init__(
            self,
            result_keys: tuple = BASE_PLAYLIST_RESULT_KEYS,
    ) -&gt; None:
        super().__init__()
        self.result_keys = result_keys

    @staticmethod
    def _get_user_playlist_id_from_video(video_id: str) -&gt; str:
        &#34;&#34;&#34;
        Returns the ID of the playlist containing the videos for the specified video ID.

        Args:
            video_id (str): The ID of the video.

        Returns:
            str: The ID of the playlist containing the videos for the specified video ID.
        &#34;&#34;&#34;
        video_downloader = VideoInfoDownloader()
        channel_id = video_downloader.download_video_data(video_id=video_id)[
            0
        ].channel_id
        return f&#34;UU{channel_id[2:]}&#34;

    def _next_page_download(
            self, next_page_token: str, playlist_id: str
    ) -&gt; PlaylistVideoData:
        &#34;&#34;&#34;
        Downloads the next page of videos from the specified playlist and returns the
        preprocessed data.

        Args:
            next_page_token (str): The token representing the next page of videos.
            playlist_id (str): The ID of the playlist to download videos from.

        Returns:
            PlaylistVideoData: An object containing the preprocessed data for the
            downloaded videos.
        &#34;&#34;&#34;
        request = self.youtube.playlistItems().list(
            part=&#34;,&#34;.join(self.result_keys),
            pageToken=next_page_token,
            playlistId=playlist_id,
        )
        response = request.execute()
        return preprocess_playlist(response)

    def get_videos_from_channel(
            self, video_id: str, video_number_limit: int = 1000
    ) -&gt; list[VideoData]:
        &#34;&#34;&#34;
        Returns a list of VideoData objects containing the video information from the
        specified channel up to the specified limit.

        Args:
            video_id (str): The ID of a video in the channel.
            video_number_limit (int): The maximum number of videos to be returned.

        Returns:
            list[VideoData]: A list of VideoData objects containing the video
            information from the specified channel up to the specified limit.
        &#34;&#34;&#34;
        playlist_id = self._get_user_playlist_id_from_video(video_id)
        request = self.youtube.playlistItems().list(
            part=&#34;,&#34;.join(self.result_keys), playlistId=playlist_id
        )
        response = request.execute()
        playlist_data = preprocess_playlist(response)
        video_data: list[VideoData] = [*playlist_data.video_data]
        next_page_token = playlist_data.next_page_token

        while next_page_token is not None and len(video_data) &lt; video_number_limit:
            playlist_data = self._next_page_download(
                next_page_token=next_page_token, playlist_id=playlist_id
            )
            video_data.extend(playlist_data.video_data)

        return video_data


if __name__ == &#34;__main__&#34;:
    channel = ChannelInfoDownloader()
    pprint.pprint(
        channel._get_user_playlist_id_from_video(video_id=&#34;1fUpkq7urDU&#34;)
    )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="auto_shorts.video_download.download_info.preprocess_playlist"><code class="name flex">
<span>def <span class="ident">preprocess_playlist</span></span>(<span>playlist_response) ‑> <a title="auto_shorts.video_download.download_info.PlaylistVideoData" href="#auto_shorts.video_download.download_info.PlaylistVideoData">PlaylistVideoData</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preprocess_playlist(playlist_response) -&gt; PlaylistVideoData:
    items = safe_get(playlist_response, &#34;items&#34;)
    video_data = [preprocess_playlist_item_response(video_data) for video_data in items]
    next_page_token = safe_get(playlist_response, &#34;nextPageToken&#34;)
    return PlaylistVideoData(video_data=video_data, next_page_token=next_page_token)</code></pre>
</details>
</dd>
<dt id="auto_shorts.video_download.download_info.preprocess_playlist_item_response"><code class="name flex">
<span>def <span class="ident">preprocess_playlist_item_response</span></span>(<span>video_data) ‑> <a title="auto_shorts.video_download.download_info.VideoData" href="#auto_shorts.video_download.download_info.VideoData">VideoData</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preprocess_playlist_item_response(video_data) -&gt; VideoData:
    video_data_dict = preprocess_video_response(video_data).dict()
    idx = safe_get(video_data, &#34;contentDetails&#34;, &#34;videoId&#34;)
    video_data_dict[&#34;id&#34;] = idx
    return VideoData(**video_data_dict)</code></pre>
</details>
</dd>
<dt id="auto_shorts.video_download.download_info.preprocess_video_response"><code class="name flex">
<span>def <span class="ident">preprocess_video_response</span></span>(<span>video_data) ‑> <a title="auto_shorts.video_download.download_info.VideoData" href="#auto_shorts.video_download.download_info.VideoData">VideoData</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preprocess_video_response(video_data) -&gt; VideoData:
    return VideoData(
        id=safe_get(
            video_data,
            &#34;id&#34;,
        ),
        channel_id=safe_get(video_data, &#34;snippet&#34;, &#34;channelId&#34;),
        channel_title=safe_get(video_data, &#34;snippet&#34;, &#34;channelTitle&#34;),
        licensed=safe_get(video_data, &#34;contentDetails&#34;, &#34;licensedContent&#34;),
        audio_language=safe_get(video_data, &#34;snippet&#34;, &#34;defaultAudioLanguage&#34;),
        decripton=safe_get(video_data, &#34;snippet&#34;, &#34;description&#34;),
        published_at=safe_get(video_data, &#34;snippet&#34;, &#34;publishedAt&#34;),
        category_id=safe_get(video_data, &#34;snippet&#34;, &#34;categoryId&#34;),
        tags=safe_get(video_data, &#34;snippet&#34;, &#34;tags&#34;),
        title=safe_get(video_data, &#34;snippet&#34;, &#34;title&#34;),
    )</code></pre>
</details>
</dd>
<dt id="auto_shorts.video_download.download_info.preprocess_video_response_with_stats"><code class="name flex">
<span>def <span class="ident">preprocess_video_response_with_stats</span></span>(<span>video_data) ‑> <a title="auto_shorts.video_download.download_info.VideoDataWithStats" href="#auto_shorts.video_download.download_info.VideoDataWithStats">VideoDataWithStats</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preprocess_video_response_with_stats(video_data) -&gt; VideoDataWithStats:
    base_response = preprocess_video_response(video_data)
    statistics_data = safe_get(video_data, &#34;statistics&#34;)
    statistics = VideoStatistics(
        comments=safe_get(statistics_data, &#34;commentCount&#34;),
        likes=safe_get(statistics_data, &#34;likeCount&#34;),
        views=safe_get(statistics_data, &#34;viewCount&#34;),
    )
    return VideoDataWithStats(**base_response.dict(), statistics=statistics)</code></pre>
</details>
</dd>
<dt id="auto_shorts.video_download.download_info.safe_get"><code class="name flex">
<span>def <span class="ident">safe_get</span></span>(<span>dct: dict, *keys) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Safely retrieve a value from a nested dictionary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dct</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary containing nested keys and values.</dd>
<dt><strong><code>*keys</code></strong> :&ensp;<code>Any</code></dt>
<dd>One or more keys to use when traversing the dictionary.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>The value at the end of the key traversal, or None if any of the keys are missing.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def safe_get(dct: dict, *keys) -&gt; Any:
    &#34;&#34;&#34;Safely retrieve a value from a nested dictionary.

    Parameters
    ----------
    dct : dict
        A dictionary containing nested keys and values.
    *keys : Any
        One or more keys to use when traversing the dictionary.

    Returns
    -------
    Any
        The value at the end of the key traversal, or None if any of the keys are missing.

    &#34;&#34;&#34;
    for key in keys:
        try:
            dct = dct[key]
        except KeyError:
            return None
    return dct</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="auto_shorts.video_download.download_info.CategoryInfoDownloader"><code class="flex name class">
<span>class <span class="ident">CategoryInfoDownloader</span></span>
<span>(</span><span>api_key: str = None, api_service_name: str = 'youtube', api_version: str = 'v3')</span>
</code></dt>
<dd>
<div class="desc"><p>Class for downloading information about video categories from YouTube API.</p>
<h2 id="methods">Methods</h2>
<p>video_categories_by_region(region_code save_path)
Fetches video categories for the given region code from the YouTube API.</p>
<p>Initializes a new instance of the InfoDownloaderBase class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>api_key</code></strong> :&ensp;<code>str</code></dt>
<dd>Your GCP API key.</dd>
<dt><strong><code>api_service_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the API service to use (default: "youtube").</dd>
<dt><strong><code>api_version</code></strong> :&ensp;<code>str</code></dt>
<dd>The version of the API to use (default: "v3").</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CategoryInfoDownloader(InfoDownloaderBase):
    &#34;&#34;&#34;
    Class for downloading information about video categories from YouTube API.

    Methods:
        video_categories_by_region(region_code save_path)
            Fetches video categories for the given region code from the YouTube API.
    &#34;&#34;&#34;
    def video_categories_by_region(
            self, region_code: str, save_path: Path | None = None
    ) -&gt; list[VideoCategory]:
        &#34;&#34;&#34;
        Fetches video categories for the given region code from the YouTube API.

        Parameters
        ----------
        region_code : str
            The two-letter ISO 3166-1 alpha-2 country code for the region whose video categories are to be fetched.
        save_path : Optional[Path], optional
            The path where the fetched video categories data should be saved as a JSON file. Default value is None,
            which means the data won&#39;t be saved.

        Returns
        -------
        categories : List[VideoCategory]
            A list of VideoCategory objects, where each object contains information about a single video category.

        Raises
        ------
        HttpError
            If there&#39;s an error in fetching the video categories data from the YouTube API.
            &#34;&#34;&#34;
        request = self.youtube.videoCategories().list(
            part=&#34;snippet&#34;, regionCode=region_code
        )
        response = request.execute()
        categories = []

        for item in response[&#34;items&#34;]:
            snippet = item[&#34;snippet&#34;]
            category = VideoCategory(
                region_code=region_code,
                category_id=item[&#34;id&#34;],
                assignable=snippet[&#34;assignable&#34;],
                category_title=snippet[&#34;title&#34;],
            )
            categories.append(category)

        if save_path:
            os.makedirs(save_path, exist_ok=True)
            with open(save_path / f&#34;{region_code}.json&#34;, &#34;w&#34;) as file:
                json.dump(
                    [category.dict() for category in categories],
                    file,
                    indent=4,
                )

        return categories</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="auto_shorts.video_download.download_info.InfoDownloaderBase" href="#auto_shorts.video_download.download_info.InfoDownloaderBase">InfoDownloaderBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="auto_shorts.video_download.download_info.CategoryInfoDownloader.video_categories_by_region"><code class="name flex">
<span>def <span class="ident">video_categories_by_region</span></span>(<span>self, region_code: str, save_path: pathlib.Path | None = None) ‑> list[<a title="auto_shorts.video_download.download_info.VideoCategory" href="#auto_shorts.video_download.download_info.VideoCategory">VideoCategory</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Fetches video categories for the given region code from the YouTube API.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>region_code</code></strong> :&ensp;<code>str</code></dt>
<dd>The two-letter ISO 3166-1 alpha-2 country code for the region whose video categories are to be fetched.</dd>
<dt><strong><code>save_path</code></strong> :&ensp;<code>Optional[Path]</code>, optional</dt>
<dd>The path where the fetched video categories data should be saved as a JSON file. Default value is None,
which means the data won't be saved.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>categories</code></strong> :&ensp;<code>List[<a title="auto_shorts.video_download.download_info.VideoCategory" href="#auto_shorts.video_download.download_info.VideoCategory">VideoCategory</a>]</code></dt>
<dd>A list of VideoCategory objects, where each object contains information about a single video category.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>HttpError</code></dt>
<dd>If there's an error in fetching the video categories data from the YouTube API.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def video_categories_by_region(
        self, region_code: str, save_path: Path | None = None
) -&gt; list[VideoCategory]:
    &#34;&#34;&#34;
    Fetches video categories for the given region code from the YouTube API.

    Parameters
    ----------
    region_code : str
        The two-letter ISO 3166-1 alpha-2 country code for the region whose video categories are to be fetched.
    save_path : Optional[Path], optional
        The path where the fetched video categories data should be saved as a JSON file. Default value is None,
        which means the data won&#39;t be saved.

    Returns
    -------
    categories : List[VideoCategory]
        A list of VideoCategory objects, where each object contains information about a single video category.

    Raises
    ------
    HttpError
        If there&#39;s an error in fetching the video categories data from the YouTube API.
        &#34;&#34;&#34;
    request = self.youtube.videoCategories().list(
        part=&#34;snippet&#34;, regionCode=region_code
    )
    response = request.execute()
    categories = []

    for item in response[&#34;items&#34;]:
        snippet = item[&#34;snippet&#34;]
        category = VideoCategory(
            region_code=region_code,
            category_id=item[&#34;id&#34;],
            assignable=snippet[&#34;assignable&#34;],
            category_title=snippet[&#34;title&#34;],
        )
        categories.append(category)

    if save_path:
        os.makedirs(save_path, exist_ok=True)
        with open(save_path / f&#34;{region_code}.json&#34;, &#34;w&#34;) as file:
            json.dump(
                [category.dict() for category in categories],
                file,
                indent=4,
            )

    return categories</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="auto_shorts.video_download.download_info.ChannelInfoDownloader"><code class="flex name class">
<span>class <span class="ident">ChannelInfoDownloader</span></span>
<span>(</span><span>result_keys: tuple = ('contentDetails', 'snippet'))</span>
</code></dt>
<dd>
<div class="desc"><p>A class for downloading information about videos from a YouTube channel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>result_keys</code></strong> :&ensp;<code>tuple</code></dt>
<dd>A tuple of keys to be included in the request for the
channel's video information.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>_get_user_playlist_id_from_video(video_id: str) -&gt; str:
Returns the ID of the playlist containing the videos for the specified
video ID.</p>
<p>_next_page_download(next_page_token: str, playlist_id: str) -&gt; PlaylistVideoData:
Downloads the next page of videos from the specified playlist and returns
the preprocessed data.</p>
<p>get_videos_from_channel(video_id: str, video_number_limit: int = 1000)
-&gt; list[VideoData]:
Returns a list of VideoData objects containing the video information from
the specified channel up to the specified limit.</p>
<p>Initializes a new instance of the InfoDownloaderBase class.</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>api_key</code></strong> :&ensp;<code>str</code></dt>
<dd>Your GCP API key.</dd>
<dt><strong><code>api_service_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the API service to use (default: "youtube").</dd>
<dt><strong><code>api_version</code></strong> :&ensp;<code>str</code></dt>
<dd>The version of the API to use (default: "v3").</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChannelInfoDownloader(InfoDownloaderBase):
    &#34;&#34;&#34;
    A class for downloading information about videos from a YouTube channel.

    Args:
        result_keys (tuple): A tuple of keys to be included in the request for the
            channel&#39;s video information.

    Methods:
        _get_user_playlist_id_from_video(video_id: str) -&gt; str:
            Returns the ID of the playlist containing the videos for the specified
            video ID.

        _next_page_download(next_page_token: str, playlist_id: str) -&gt; PlaylistVideoData:
            Downloads the next page of videos from the specified playlist and returns
            the preprocessed data.

        get_videos_from_channel(video_id: str, video_number_limit: int = 1000)
            -&gt; list[VideoData]:
            Returns a list of VideoData objects containing the video information from
            the specified channel up to the specified limit.
    &#34;&#34;&#34;
    def __init__(
            self,
            result_keys: tuple = BASE_PLAYLIST_RESULT_KEYS,
    ) -&gt; None:
        super().__init__()
        self.result_keys = result_keys

    @staticmethod
    def _get_user_playlist_id_from_video(video_id: str) -&gt; str:
        &#34;&#34;&#34;
        Returns the ID of the playlist containing the videos for the specified video ID.

        Args:
            video_id (str): The ID of the video.

        Returns:
            str: The ID of the playlist containing the videos for the specified video ID.
        &#34;&#34;&#34;
        video_downloader = VideoInfoDownloader()
        channel_id = video_downloader.download_video_data(video_id=video_id)[
            0
        ].channel_id
        return f&#34;UU{channel_id[2:]}&#34;

    def _next_page_download(
            self, next_page_token: str, playlist_id: str
    ) -&gt; PlaylistVideoData:
        &#34;&#34;&#34;
        Downloads the next page of videos from the specified playlist and returns the
        preprocessed data.

        Args:
            next_page_token (str): The token representing the next page of videos.
            playlist_id (str): The ID of the playlist to download videos from.

        Returns:
            PlaylistVideoData: An object containing the preprocessed data for the
            downloaded videos.
        &#34;&#34;&#34;
        request = self.youtube.playlistItems().list(
            part=&#34;,&#34;.join(self.result_keys),
            pageToken=next_page_token,
            playlistId=playlist_id,
        )
        response = request.execute()
        return preprocess_playlist(response)

    def get_videos_from_channel(
            self, video_id: str, video_number_limit: int = 1000
    ) -&gt; list[VideoData]:
        &#34;&#34;&#34;
        Returns a list of VideoData objects containing the video information from the
        specified channel up to the specified limit.

        Args:
            video_id (str): The ID of a video in the channel.
            video_number_limit (int): The maximum number of videos to be returned.

        Returns:
            list[VideoData]: A list of VideoData objects containing the video
            information from the specified channel up to the specified limit.
        &#34;&#34;&#34;
        playlist_id = self._get_user_playlist_id_from_video(video_id)
        request = self.youtube.playlistItems().list(
            part=&#34;,&#34;.join(self.result_keys), playlistId=playlist_id
        )
        response = request.execute()
        playlist_data = preprocess_playlist(response)
        video_data: list[VideoData] = [*playlist_data.video_data]
        next_page_token = playlist_data.next_page_token

        while next_page_token is not None and len(video_data) &lt; video_number_limit:
            playlist_data = self._next_page_download(
                next_page_token=next_page_token, playlist_id=playlist_id
            )
            video_data.extend(playlist_data.video_data)

        return video_data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="auto_shorts.video_download.download_info.InfoDownloaderBase" href="#auto_shorts.video_download.download_info.InfoDownloaderBase">InfoDownloaderBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="auto_shorts.video_download.download_info.ChannelInfoDownloader.get_videos_from_channel"><code class="name flex">
<span>def <span class="ident">get_videos_from_channel</span></span>(<span>self, video_id: str, video_number_limit: int = 1000) ‑> list[<a title="auto_shorts.video_download.download_info.VideoData" href="#auto_shorts.video_download.download_info.VideoData">VideoData</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of VideoData objects containing the video information from the
specified channel up to the specified limit.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>video_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of a video in the channel.</dd>
<dt><strong><code>video_number_limit</code></strong> :&ensp;<code>int</code></dt>
<dd>The maximum number of videos to be returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[<a title="auto_shorts.video_download.download_info.VideoData" href="#auto_shorts.video_download.download_info.VideoData">VideoData</a>]</code></dt>
<dd>A list of VideoData objects containing the video</dd>
</dl>
<p>information from the specified channel up to the specified limit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_videos_from_channel(
        self, video_id: str, video_number_limit: int = 1000
) -&gt; list[VideoData]:
    &#34;&#34;&#34;
    Returns a list of VideoData objects containing the video information from the
    specified channel up to the specified limit.

    Args:
        video_id (str): The ID of a video in the channel.
        video_number_limit (int): The maximum number of videos to be returned.

    Returns:
        list[VideoData]: A list of VideoData objects containing the video
        information from the specified channel up to the specified limit.
    &#34;&#34;&#34;
    playlist_id = self._get_user_playlist_id_from_video(video_id)
    request = self.youtube.playlistItems().list(
        part=&#34;,&#34;.join(self.result_keys), playlistId=playlist_id
    )
    response = request.execute()
    playlist_data = preprocess_playlist(response)
    video_data: list[VideoData] = [*playlist_data.video_data]
    next_page_token = playlist_data.next_page_token

    while next_page_token is not None and len(video_data) &lt; video_number_limit:
        playlist_data = self._next_page_download(
            next_page_token=next_page_token, playlist_id=playlist_id
        )
        video_data.extend(playlist_data.video_data)

    return video_data</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="auto_shorts.video_download.download_info.InfoDownloaderBase"><code class="flex name class">
<span>class <span class="ident">InfoDownloaderBase</span></span>
<span>(</span><span>api_key: str = None, api_service_name: str = 'youtube', api_version: str = 'v3')</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for downloading data from the YouTube API.</p>
<p>Initializes a new instance of the InfoDownloaderBase class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>api_key</code></strong> :&ensp;<code>str</code></dt>
<dd>Your GCP API key.</dd>
<dt><strong><code>api_service_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the API service to use (default: "youtube").</dd>
<dt><strong><code>api_version</code></strong> :&ensp;<code>str</code></dt>
<dd>The version of the API to use (default: "v3").</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InfoDownloaderBase:
    &#34;&#34;&#34;
    Base class for downloading data from the YouTube API.
    &#34;&#34;&#34;
    def __init__(
            self,
            api_key: str = GCP_API_KEY,
            api_service_name: str = &#34;youtube&#34;,
            api_version: str = &#34;v3&#34;,
    ) -&gt; None:
        &#34;&#34;&#34;
        Initializes a new instance of the InfoDownloaderBase class.

        Args:
            api_key (str): Your GCP API key.
            api_service_name (str): The name of the API service to use (default: &#34;youtube&#34;).
            api_version (str): The version of the API to use (default: &#34;v3&#34;).
        &#34;&#34;&#34;
        self.youtube = googleapiclient.discovery.build(
            api_service_name, api_version, developerKey=api_key
        )</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="auto_shorts.video_download.download_info.CategoryInfoDownloader" href="#auto_shorts.video_download.download_info.CategoryInfoDownloader">CategoryInfoDownloader</a></li>
<li><a title="auto_shorts.video_download.download_info.ChannelInfoDownloader" href="#auto_shorts.video_download.download_info.ChannelInfoDownloader">ChannelInfoDownloader</a></li>
<li><a title="auto_shorts.video_download.download_info.VideoInfoDownloader" href="#auto_shorts.video_download.download_info.VideoInfoDownloader">VideoInfoDownloader</a></li>
</ul>
</dd>
<dt id="auto_shorts.video_download.download_info.PlaylistVideoData"><code class="flex name class">
<span>class <span class="ident">PlaylistVideoData</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PlaylistVideoData(BaseModel):
    video_data: list[VideoData]
    next_page_token: str | None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="auto_shorts.video_download.download_info.PlaylistVideoData.next_page_token"><code class="name">var <span class="ident">next_page_token</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="auto_shorts.video_download.download_info.PlaylistVideoData.video_data"><code class="name">var <span class="ident">video_data</span> : list[<a title="auto_shorts.video_download.download_info.VideoData" href="#auto_shorts.video_download.download_info.VideoData">VideoData</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="auto_shorts.video_download.download_info.VideoCategory"><code class="flex name class">
<span>class <span class="ident">VideoCategory</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Class representing a video category on YouTube.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>region_code</code></strong> :&ensp;<code>str</code></dt>
<dd>The two-letter ISO 3166-1 alpha-2 country code for the region to which the video category belongs.</dd>
<dt><strong><code>category_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the video category.</dd>
<dt><strong><code>assignable</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the video category can be used as a target for new videos.</dd>
<dt><strong><code>category_title</code></strong> :&ensp;<code>str</code></dt>
<dd>The title of the video category.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VideoCategory(BaseModel):
    &#34;&#34;&#34;
    Class representing a video category on YouTube.

    Attributes
    ----------
    region_code : str
        The two-letter ISO 3166-1 alpha-2 country code for the region to which the video category belongs.
    category_id : str
        The ID of the video category.
    assignable : bool
        Whether the video category can be used as a target for new videos.
    category_title : str
        The title of the video category.
    &#34;&#34;&#34;
    region_code: str
    category_id: int
    category_title: str
    assignable: bool</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="auto_shorts.video_download.download_info.VideoCategory.assignable"><code class="name">var <span class="ident">assignable</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="auto_shorts.video_download.download_info.VideoCategory.category_id"><code class="name">var <span class="ident">category_id</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="auto_shorts.video_download.download_info.VideoCategory.category_title"><code class="name">var <span class="ident">category_title</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="auto_shorts.video_download.download_info.VideoCategory.region_code"><code class="name">var <span class="ident">region_code</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="auto_shorts.video_download.download_info.VideoData"><code class="flex name class">
<span>class <span class="ident">VideoData</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VideoData(BaseModel):
    id: str
    channel_id: str | None
    channel_title: str | None
    audio_language: str | None
    licensed: bool | None
    description: str | None
    published_at: str | None
    category_id: str | None
    tags: list[str] | None
    title: str | None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="auto_shorts.video_download.download_info.VideoDataWithStats" href="#auto_shorts.video_download.download_info.VideoDataWithStats">VideoDataWithStats</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="auto_shorts.video_download.download_info.VideoData.audio_language"><code class="name">var <span class="ident">audio_language</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="auto_shorts.video_download.download_info.VideoData.category_id"><code class="name">var <span class="ident">category_id</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="auto_shorts.video_download.download_info.VideoData.channel_id"><code class="name">var <span class="ident">channel_id</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="auto_shorts.video_download.download_info.VideoData.channel_title"><code class="name">var <span class="ident">channel_title</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="auto_shorts.video_download.download_info.VideoData.description"><code class="name">var <span class="ident">description</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="auto_shorts.video_download.download_info.VideoData.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="auto_shorts.video_download.download_info.VideoData.licensed"><code class="name">var <span class="ident">licensed</span> : bool | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="auto_shorts.video_download.download_info.VideoData.published_at"><code class="name">var <span class="ident">published_at</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="auto_shorts.video_download.download_info.VideoData.tags"><code class="name">var <span class="ident">tags</span> : list[str] | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="auto_shorts.video_download.download_info.VideoData.title"><code class="name">var <span class="ident">title</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="auto_shorts.video_download.download_info.VideoDataWithStats"><code class="flex name class">
<span>class <span class="ident">VideoDataWithStats</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VideoDataWithStats(VideoData):
    statistics: VideoStatistics | None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="auto_shorts.video_download.download_info.VideoData" href="#auto_shorts.video_download.download_info.VideoData">VideoData</a></li>
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="auto_shorts.video_download.download_video.VideoDataWithMoments" href="download_video.html#auto_shorts.video_download.download_video.VideoDataWithMoments">VideoDataWithMoments</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="auto_shorts.video_download.download_info.VideoDataWithStats.statistics"><code class="name">var <span class="ident">statistics</span> : <a title="auto_shorts.video_download.download_info.VideoStatistics" href="#auto_shorts.video_download.download_info.VideoStatistics">VideoStatistics</a> | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="auto_shorts.video_download.download_info.VideoInfoDownloader"><code class="flex name class">
<span>class <span class="ident">VideoInfoDownloader</span></span>
<span>(</span><span>result_keys: list = ('contentDetails', 'snippet', 'statistics'))</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads video information from YouTube using YouTube API v3.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>result_keys</code></strong> :&ensp;<code>list</code></dt>
<dd>List of video information keys to download.
Defaults to BASE_RESULT_KEYS.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>most_popular_videos(region_code, video_category_id, max_results):
Returns the most popular videos for a given region or category.</p>
<p>id_from_response(response):
Extracts video ids from a response dictionary.</p>
<p>download_video_data(video_id):
Downloads video data for one or more video ids.</p>
<p>video_id_by_page_token(page_token):
Extracts video ids and a next page token from a page token.</p>
<p>video_id_by_search_query(q, max_results, order):
Returns video ids for a search query.</p>
<p>video_data_by_search_query(q, max_results, order):
Returns video data for a search query.</p>
<p>Initializes a new instance of the InfoDownloaderBase class.</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>api_key</code></strong> :&ensp;<code>str</code></dt>
<dd>Your GCP API key.</dd>
<dt><strong><code>api_service_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the API service to use (default: "youtube").</dd>
<dt><strong><code>api_version</code></strong> :&ensp;<code>str</code></dt>
<dd>The version of the API to use (default: "v3").</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VideoInfoDownloader(InfoDownloaderBase):
    &#34;&#34;&#34;
    Downloads video information from YouTube using YouTube API v3.

    Args:
        result_keys (list): List of video information keys to download.
            Defaults to BASE_RESULT_KEYS.

    Methods:
        most_popular_videos(region_code, video_category_id, max_results):
            Returns the most popular videos for a given region or category.

        id_from_response(response):
            Extracts video ids from a response dictionary.

        download_video_data(video_id):
            Downloads video data for one or more video ids.

        video_id_by_page_token(page_token):
            Extracts video ids and a next page token from a page token.

        video_id_by_search_query(q, max_results, order):
            Returns video ids for a search query.

        video_data_by_search_query(q, max_results, order):
            Returns video data for a search query.
    &#34;&#34;&#34;
    def __init__(
            self,
            result_keys: list = BASE_RESULT_KEYS,
    ) -&gt; None:
        super().__init__()
        self.result_keys = result_keys

    def most_popular_videos(
            self,
            region_code: str | None = None,
            video_category_id: int | None = None,
            max_results: int | None = 100,
    ) -&gt; list[VideoDataWithStats]:
        &#34;&#34;&#34;
        Returns the most popular videos for a given region or category.

        Args:
            region_code (str): ISO 3166-1 alpha-2 code of the region. Defaults
                to None.
            video_category_id (int): ID of the video category. Defaults to None.
            max_results (int): Maximum number of results to return. Defaults to
                100.

        Returns:
            A list of VideoDataWithStats objects.
        &#34;&#34;&#34;
        request = self.youtube.videos().list(
            part=&#34;,&#34;.join(self.result_keys),
            chart=&#34;mostPopular&#34;,
            regionCode=region_code,
            videoCategoryId=video_category_id,
            maxResults=max_results,
        )
        all_videos = request.execute()[&#34;items&#34;]
        return [
            preprocess_video_response_with_stats(video_data)
            for video_data in all_videos
        ]

    @staticmethod
    def id_from_response(response: dict) -&gt; list[str]:
        &#34;&#34;&#34;
        Extracts video ids from a response dictionary.

        Args:
            response (dict): The response dictionary.

        Returns:
            A list of video ids.
        &#34;&#34;&#34;
        return [
            safe_get(video_data, &#34;id&#34;, &#34;videoId&#34;) for video_data in response[&#34;items&#34;]
        ]

    def download_video_data(self, video_id: str) -&gt; list[VideoDataWithStats]:
        &#34;&#34;&#34;
        Downloads video data for one or more video ids.

        Args:
            video_id (str): One or more video ids separated by comma.

        Returns:
            A list of VideoDataWithStats objects.
        &#34;&#34;&#34;
        request = self.youtube.videos().list(
            part=&#34;,&#34;.join(self.result_keys), id=video_id
        )
        response = request.execute()[&#34;items&#34;]
        video_data_preprocessed = []

        for video_data in response:
            video_data_preprocessed.append(
                preprocess_video_response_with_stats(video_data)
            )

        return video_data_preprocessed

    def video_id_by_page_token(self, page_token: str) -&gt; tuple[list[str], str]:
        &#34;&#34;&#34;
        Extracts video ids and a next page token from API using previous page token.

        Args:
            page_token (str): A page token.

        Returns:
            A tuple of a list of video ids and the next page token.
        &#34;&#34;&#34;
        request = self.youtube.search().list(part=&#34;snippet&#34;, pageToken=page_token)
        response = request.execute()
        try:
            next_page_token = response[&#34;nextPageToken&#34;]
            return self.id_from_response(response), next_page_token
        except KeyError:
            pprint.pprint(response)

    def video_id_by_search_query(
            self, q: str, max_results: int = 100, order: str = &#34;viewCount&#34;
    ) -&gt; list[str]:
        &#34;&#34;&#34;
        Returns video ids for a search query.

        Args:
            q (str): The search query.
            max_results (int): Maximum number of results to return. Defaults to
                100.
            order (str): The order of the results. Defaults to &#34;viewCount&#34;.

        Returns:
            A list of video ids.
        &#34;&#34;&#34;
        request = self.youtube.search().list(
            q=q,
            part=&#34;snippet&#34;,
            maxResults=max_results,
            order=order,
            type=&#34;video&#34;
            # videoLicense=&#34;creativeCommon&#34;, To check later!
        )
        response = request.execute()
        video_id = self.id_from_response(response)
        next_page_token = response[&#34;nextPageToken&#34;]

        while len(video_id) &lt; max_results:
            tmp_video_id, next_page_token = self.video_id_by_page_token(next_page_token)
            video_id.extend(tmp_video_id)

        return video_id

    def video_data_by_search_query(
            self, q: str, max_results: int = 100, order: str = &#34;viewCount&#34;
    ) -&gt; list[VideoDataWithStats]:
        &#34;&#34;&#34;
        Returns video data for a search query.

        Args:
            q (str): The search query.
            max_results (int): Maximum number of results to return. Defaults to
                100.
            order (str): The order of the results. Defaults to &#34;viewCount&#34;.

        Returns:
            A list of VideoDataWithStats objects.
        &#34;&#34;&#34;
        video_id = self.video_id_by_search_query(
            q=q, max_results=max_results, order=order
        )
        return self.download_video_data(video_id=&#34;,&#34;.join(video_id))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="auto_shorts.video_download.download_info.InfoDownloaderBase" href="#auto_shorts.video_download.download_info.InfoDownloaderBase">InfoDownloaderBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="auto_shorts.video_download.download_info.VideoInfoDownloader.id_from_response"><code class="name flex">
<span>def <span class="ident">id_from_response</span></span>(<span>response: dict) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Extracts video ids from a response dictionary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>response</code></strong> :&ensp;<code>dict</code></dt>
<dd>The response dictionary.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of video ids.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def id_from_response(response: dict) -&gt; list[str]:
    &#34;&#34;&#34;
    Extracts video ids from a response dictionary.

    Args:
        response (dict): The response dictionary.

    Returns:
        A list of video ids.
    &#34;&#34;&#34;
    return [
        safe_get(video_data, &#34;id&#34;, &#34;videoId&#34;) for video_data in response[&#34;items&#34;]
    ]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="auto_shorts.video_download.download_info.VideoInfoDownloader.download_video_data"><code class="name flex">
<span>def <span class="ident">download_video_data</span></span>(<span>self, video_id: str) ‑> list[<a title="auto_shorts.video_download.download_info.VideoDataWithStats" href="#auto_shorts.video_download.download_info.VideoDataWithStats">VideoDataWithStats</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads video data for one or more video ids.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>video_id</code></strong> :&ensp;<code>str</code></dt>
<dd>One or more video ids separated by comma.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of VideoDataWithStats objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download_video_data(self, video_id: str) -&gt; list[VideoDataWithStats]:
    &#34;&#34;&#34;
    Downloads video data for one or more video ids.

    Args:
        video_id (str): One or more video ids separated by comma.

    Returns:
        A list of VideoDataWithStats objects.
    &#34;&#34;&#34;
    request = self.youtube.videos().list(
        part=&#34;,&#34;.join(self.result_keys), id=video_id
    )
    response = request.execute()[&#34;items&#34;]
    video_data_preprocessed = []

    for video_data in response:
        video_data_preprocessed.append(
            preprocess_video_response_with_stats(video_data)
        )

    return video_data_preprocessed</code></pre>
</details>
</dd>
<dt id="auto_shorts.video_download.download_info.VideoInfoDownloader.most_popular_videos"><code class="name flex">
<span>def <span class="ident">most_popular_videos</span></span>(<span>self, region_code: str | None = None, video_category_id: int | None = None, max_results: int | None = 100) ‑> list[<a title="auto_shorts.video_download.download_info.VideoDataWithStats" href="#auto_shorts.video_download.download_info.VideoDataWithStats">VideoDataWithStats</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the most popular videos for a given region or category.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>region_code</code></strong> :&ensp;<code>str</code></dt>
<dd>ISO 3166-1 alpha-2 code of the region. Defaults
to None.</dd>
<dt><strong><code>video_category_id</code></strong> :&ensp;<code>int</code></dt>
<dd>ID of the video category. Defaults to None.</dd>
<dt><strong><code>max_results</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of results to return. Defaults to
100.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of VideoDataWithStats objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def most_popular_videos(
        self,
        region_code: str | None = None,
        video_category_id: int | None = None,
        max_results: int | None = 100,
) -&gt; list[VideoDataWithStats]:
    &#34;&#34;&#34;
    Returns the most popular videos for a given region or category.

    Args:
        region_code (str): ISO 3166-1 alpha-2 code of the region. Defaults
            to None.
        video_category_id (int): ID of the video category. Defaults to None.
        max_results (int): Maximum number of results to return. Defaults to
            100.

    Returns:
        A list of VideoDataWithStats objects.
    &#34;&#34;&#34;
    request = self.youtube.videos().list(
        part=&#34;,&#34;.join(self.result_keys),
        chart=&#34;mostPopular&#34;,
        regionCode=region_code,
        videoCategoryId=video_category_id,
        maxResults=max_results,
    )
    all_videos = request.execute()[&#34;items&#34;]
    return [
        preprocess_video_response_with_stats(video_data)
        for video_data in all_videos
    ]</code></pre>
</details>
</dd>
<dt id="auto_shorts.video_download.download_info.VideoInfoDownloader.video_data_by_search_query"><code class="name flex">
<span>def <span class="ident">video_data_by_search_query</span></span>(<span>self, q: str, max_results: int = 100, order: str = 'viewCount') ‑> list[<a title="auto_shorts.video_download.download_info.VideoDataWithStats" href="#auto_shorts.video_download.download_info.VideoDataWithStats">VideoDataWithStats</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns video data for a search query.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>q</code></strong> :&ensp;<code>str</code></dt>
<dd>The search query.</dd>
<dt><strong><code>max_results</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of results to return. Defaults to
100.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>str</code></dt>
<dd>The order of the results. Defaults to "viewCount".</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of VideoDataWithStats objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def video_data_by_search_query(
        self, q: str, max_results: int = 100, order: str = &#34;viewCount&#34;
) -&gt; list[VideoDataWithStats]:
    &#34;&#34;&#34;
    Returns video data for a search query.

    Args:
        q (str): The search query.
        max_results (int): Maximum number of results to return. Defaults to
            100.
        order (str): The order of the results. Defaults to &#34;viewCount&#34;.

    Returns:
        A list of VideoDataWithStats objects.
    &#34;&#34;&#34;
    video_id = self.video_id_by_search_query(
        q=q, max_results=max_results, order=order
    )
    return self.download_video_data(video_id=&#34;,&#34;.join(video_id))</code></pre>
</details>
</dd>
<dt id="auto_shorts.video_download.download_info.VideoInfoDownloader.video_id_by_page_token"><code class="name flex">
<span>def <span class="ident">video_id_by_page_token</span></span>(<span>self, page_token: str) ‑> tuple[list[str], str]</span>
</code></dt>
<dd>
<div class="desc"><p>Extracts video ids and a next page token from API using previous page token.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>page_token</code></strong> :&ensp;<code>str</code></dt>
<dd>A page token.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple of a list of video ids and the next page token.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def video_id_by_page_token(self, page_token: str) -&gt; tuple[list[str], str]:
    &#34;&#34;&#34;
    Extracts video ids and a next page token from API using previous page token.

    Args:
        page_token (str): A page token.

    Returns:
        A tuple of a list of video ids and the next page token.
    &#34;&#34;&#34;
    request = self.youtube.search().list(part=&#34;snippet&#34;, pageToken=page_token)
    response = request.execute()
    try:
        next_page_token = response[&#34;nextPageToken&#34;]
        return self.id_from_response(response), next_page_token
    except KeyError:
        pprint.pprint(response)</code></pre>
</details>
</dd>
<dt id="auto_shorts.video_download.download_info.VideoInfoDownloader.video_id_by_search_query"><code class="name flex">
<span>def <span class="ident">video_id_by_search_query</span></span>(<span>self, q: str, max_results: int = 100, order: str = 'viewCount') ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns video ids for a search query.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>q</code></strong> :&ensp;<code>str</code></dt>
<dd>The search query.</dd>
<dt><strong><code>max_results</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of results to return. Defaults to
100.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>str</code></dt>
<dd>The order of the results. Defaults to "viewCount".</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of video ids.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def video_id_by_search_query(
        self, q: str, max_results: int = 100, order: str = &#34;viewCount&#34;
) -&gt; list[str]:
    &#34;&#34;&#34;
    Returns video ids for a search query.

    Args:
        q (str): The search query.
        max_results (int): Maximum number of results to return. Defaults to
            100.
        order (str): The order of the results. Defaults to &#34;viewCount&#34;.

    Returns:
        A list of video ids.
    &#34;&#34;&#34;
    request = self.youtube.search().list(
        q=q,
        part=&#34;snippet&#34;,
        maxResults=max_results,
        order=order,
        type=&#34;video&#34;
        # videoLicense=&#34;creativeCommon&#34;, To check later!
    )
    response = request.execute()
    video_id = self.id_from_response(response)
    next_page_token = response[&#34;nextPageToken&#34;]

    while len(video_id) &lt; max_results:
        tmp_video_id, next_page_token = self.video_id_by_page_token(next_page_token)
        video_id.extend(tmp_video_id)

    return video_id</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="auto_shorts.video_download.download_info.VideoStatistics"><code class="flex name class">
<span>class <span class="ident">VideoStatistics</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VideoStatistics(BaseModel):
    comments: int | None
    likes: int | None
    views: int | None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="auto_shorts.video_download.download_info.VideoStatistics.comments"><code class="name">var <span class="ident">comments</span> : int | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="auto_shorts.video_download.download_info.VideoStatistics.likes"><code class="name">var <span class="ident">likes</span> : int | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="auto_shorts.video_download.download_info.VideoStatistics.views"><code class="name">var <span class="ident">views</span> : int | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="auto_shorts.video_download" href="index.html">auto_shorts.video_download</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="auto_shorts.video_download.download_info.preprocess_playlist" href="#auto_shorts.video_download.download_info.preprocess_playlist">preprocess_playlist</a></code></li>
<li><code><a title="auto_shorts.video_download.download_info.preprocess_playlist_item_response" href="#auto_shorts.video_download.download_info.preprocess_playlist_item_response">preprocess_playlist_item_response</a></code></li>
<li><code><a title="auto_shorts.video_download.download_info.preprocess_video_response" href="#auto_shorts.video_download.download_info.preprocess_video_response">preprocess_video_response</a></code></li>
<li><code><a title="auto_shorts.video_download.download_info.preprocess_video_response_with_stats" href="#auto_shorts.video_download.download_info.preprocess_video_response_with_stats">preprocess_video_response_with_stats</a></code></li>
<li><code><a title="auto_shorts.video_download.download_info.safe_get" href="#auto_shorts.video_download.download_info.safe_get">safe_get</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="auto_shorts.video_download.download_info.CategoryInfoDownloader" href="#auto_shorts.video_download.download_info.CategoryInfoDownloader">CategoryInfoDownloader</a></code></h4>
<ul class="">
<li><code><a title="auto_shorts.video_download.download_info.CategoryInfoDownloader.video_categories_by_region" href="#auto_shorts.video_download.download_info.CategoryInfoDownloader.video_categories_by_region">video_categories_by_region</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="auto_shorts.video_download.download_info.ChannelInfoDownloader" href="#auto_shorts.video_download.download_info.ChannelInfoDownloader">ChannelInfoDownloader</a></code></h4>
<ul class="">
<li><code><a title="auto_shorts.video_download.download_info.ChannelInfoDownloader.get_videos_from_channel" href="#auto_shorts.video_download.download_info.ChannelInfoDownloader.get_videos_from_channel">get_videos_from_channel</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="auto_shorts.video_download.download_info.InfoDownloaderBase" href="#auto_shorts.video_download.download_info.InfoDownloaderBase">InfoDownloaderBase</a></code></h4>
</li>
<li>
<h4><code><a title="auto_shorts.video_download.download_info.PlaylistVideoData" href="#auto_shorts.video_download.download_info.PlaylistVideoData">PlaylistVideoData</a></code></h4>
<ul class="">
<li><code><a title="auto_shorts.video_download.download_info.PlaylistVideoData.next_page_token" href="#auto_shorts.video_download.download_info.PlaylistVideoData.next_page_token">next_page_token</a></code></li>
<li><code><a title="auto_shorts.video_download.download_info.PlaylistVideoData.video_data" href="#auto_shorts.video_download.download_info.PlaylistVideoData.video_data">video_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="auto_shorts.video_download.download_info.VideoCategory" href="#auto_shorts.video_download.download_info.VideoCategory">VideoCategory</a></code></h4>
<ul class="">
<li><code><a title="auto_shorts.video_download.download_info.VideoCategory.assignable" href="#auto_shorts.video_download.download_info.VideoCategory.assignable">assignable</a></code></li>
<li><code><a title="auto_shorts.video_download.download_info.VideoCategory.category_id" href="#auto_shorts.video_download.download_info.VideoCategory.category_id">category_id</a></code></li>
<li><code><a title="auto_shorts.video_download.download_info.VideoCategory.category_title" href="#auto_shorts.video_download.download_info.VideoCategory.category_title">category_title</a></code></li>
<li><code><a title="auto_shorts.video_download.download_info.VideoCategory.region_code" href="#auto_shorts.video_download.download_info.VideoCategory.region_code">region_code</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="auto_shorts.video_download.download_info.VideoData" href="#auto_shorts.video_download.download_info.VideoData">VideoData</a></code></h4>
<ul class="two-column">
<li><code><a title="auto_shorts.video_download.download_info.VideoData.audio_language" href="#auto_shorts.video_download.download_info.VideoData.audio_language">audio_language</a></code></li>
<li><code><a title="auto_shorts.video_download.download_info.VideoData.category_id" href="#auto_shorts.video_download.download_info.VideoData.category_id">category_id</a></code></li>
<li><code><a title="auto_shorts.video_download.download_info.VideoData.channel_id" href="#auto_shorts.video_download.download_info.VideoData.channel_id">channel_id</a></code></li>
<li><code><a title="auto_shorts.video_download.download_info.VideoData.channel_title" href="#auto_shorts.video_download.download_info.VideoData.channel_title">channel_title</a></code></li>
<li><code><a title="auto_shorts.video_download.download_info.VideoData.description" href="#auto_shorts.video_download.download_info.VideoData.description">description</a></code></li>
<li><code><a title="auto_shorts.video_download.download_info.VideoData.id" href="#auto_shorts.video_download.download_info.VideoData.id">id</a></code></li>
<li><code><a title="auto_shorts.video_download.download_info.VideoData.licensed" href="#auto_shorts.video_download.download_info.VideoData.licensed">licensed</a></code></li>
<li><code><a title="auto_shorts.video_download.download_info.VideoData.published_at" href="#auto_shorts.video_download.download_info.VideoData.published_at">published_at</a></code></li>
<li><code><a title="auto_shorts.video_download.download_info.VideoData.tags" href="#auto_shorts.video_download.download_info.VideoData.tags">tags</a></code></li>
<li><code><a title="auto_shorts.video_download.download_info.VideoData.title" href="#auto_shorts.video_download.download_info.VideoData.title">title</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="auto_shorts.video_download.download_info.VideoDataWithStats" href="#auto_shorts.video_download.download_info.VideoDataWithStats">VideoDataWithStats</a></code></h4>
<ul class="">
<li><code><a title="auto_shorts.video_download.download_info.VideoDataWithStats.statistics" href="#auto_shorts.video_download.download_info.VideoDataWithStats.statistics">statistics</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="auto_shorts.video_download.download_info.VideoInfoDownloader" href="#auto_shorts.video_download.download_info.VideoInfoDownloader">VideoInfoDownloader</a></code></h4>
<ul class="">
<li><code><a title="auto_shorts.video_download.download_info.VideoInfoDownloader.download_video_data" href="#auto_shorts.video_download.download_info.VideoInfoDownloader.download_video_data">download_video_data</a></code></li>
<li><code><a title="auto_shorts.video_download.download_info.VideoInfoDownloader.id_from_response" href="#auto_shorts.video_download.download_info.VideoInfoDownloader.id_from_response">id_from_response</a></code></li>
<li><code><a title="auto_shorts.video_download.download_info.VideoInfoDownloader.most_popular_videos" href="#auto_shorts.video_download.download_info.VideoInfoDownloader.most_popular_videos">most_popular_videos</a></code></li>
<li><code><a title="auto_shorts.video_download.download_info.VideoInfoDownloader.video_data_by_search_query" href="#auto_shorts.video_download.download_info.VideoInfoDownloader.video_data_by_search_query">video_data_by_search_query</a></code></li>
<li><code><a title="auto_shorts.video_download.download_info.VideoInfoDownloader.video_id_by_page_token" href="#auto_shorts.video_download.download_info.VideoInfoDownloader.video_id_by_page_token">video_id_by_page_token</a></code></li>
<li><code><a title="auto_shorts.video_download.download_info.VideoInfoDownloader.video_id_by_search_query" href="#auto_shorts.video_download.download_info.VideoInfoDownloader.video_id_by_search_query">video_id_by_search_query</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="auto_shorts.video_download.download_info.VideoStatistics" href="#auto_shorts.video_download.download_info.VideoStatistics">VideoStatistics</a></code></h4>
<ul class="">
<li><code><a title="auto_shorts.video_download.download_info.VideoStatistics.comments" href="#auto_shorts.video_download.download_info.VideoStatistics.comments">comments</a></code></li>
<li><code><a title="auto_shorts.video_download.download_info.VideoStatistics.likes" href="#auto_shorts.video_download.download_info.VideoStatistics.likes">likes</a></code></li>
<li><code><a title="auto_shorts.video_download.download_info.VideoStatistics.views" href="#auto_shorts.video_download.download_info.VideoStatistics.views">views</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>